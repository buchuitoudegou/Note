# 多版本并行控制和数据库隔离级别

1. read committed（读提交）
2. repeatable read（可重复读）
3. snapshot isolation（快照隔离）
4. serializable（串行化）

## 多版本串行化标准

1. **read stability**：事务T1读取了一个V1版本的元组，我们要保证在事务T1结束的时候，V1还没有被另一个*已提交* 的版本V2替代。利用锁机制可以保证，也可以在事务结束之前验证V1是否仍然对自己可见。
2. **phantom avoidance** ：保证事务结束时扫描和事务开始时扫描不会返回额外的结果。仍然可以用锁机制来保证这一点（索引加锁或者表加锁），也可以维护一个扫描集，结束时验证。

## 不同隔离级别的具体要求

### read committed

这个级别要求某个事务T只能读取某个已提交的值。没有串行化要求，无论读取的值是否在自己执行过程中提交的，只要时已提交的值都可以读取。不需要额外验证或者加锁。

这样也会出现一些问题，比如在事务T开始的时候读取了对象A的旧版本V1值，而在T还未结束时，事务TO修改了对象A的值，产生一个新版本V2；而T在结束前再次读取对象A的值，而这次读取到的是新版本V2——这样前后读取到的值实际上是不一致的（conflict），在某些场景中会造成错误。

### repeatable read

和读提交的区别在于，它需要满足**read stability**。即，在开始时读到的值必须和结束时读到的值是一致的。为了实现这一点，可以用2PL协议，在事务T对对象A的读结束之前，其他的事务都不允许对对象A进行写入。又或者在读取了对象A之后，将A加入到读取集，在提交之前先验证对象A是否仍对自己可见。

在多版本的2PL中（MV2PL），事务在读取的时候会根据自己的时间戳找到自己可见的版本，然后申请读锁；同理，在更新版本的时候，也会申请写锁。在事务结束的时候才释放锁。这就保证了读稳定性：在事务开始和结束的时候，对于本事务可见的版本不会被别的事务提交的新版本覆盖，导致不可见。而Hekaton的MVOCC则在读取阶段维护一个读集和写集，并在验证阶段检验自己读集中的元组是否对自己仍然可见（在验证阶段会得到一个新的时间戳，根据这个时间戳来判断）。

### snapshot isolation

根据维基百科的定义，快照隔离级别需要保证事务的读操作保证在某个一致的数据库版本中进行，即只能读取在自己开始之前就提交完成的版本。而写操作则保证，对同一个元组的最新版本有且只有一个事务的修改有效。

快照隔离级别实际上不保证**read stability**，当一个事务在读取了某个版本的元组时，这个元组可能被其他事务修改为新的版本，并提交。在Hekaton的MVOCC中，这个新提交的版本对当前事务不可见，因此并不会因为新版本提交而违反了快照隔离。也因此，Hekaton的MVOCC快照隔离实际上并不需要验证。

### serializable

可串行化是最高的隔离级别，它需要同时保证**read stability**和**phantom avoidance**，也就是说，在事务读取的元组版本在事务结束时不能被别的事务修改提交，导致这个版本在事务结束时不可见；另外，事务开始时扫描表的结果和事务结束时也应该一致，不能因为其他事务对表添加/删除元组，导致扫描结果不一致（幻读）。

保证**read stability**的方法如上文所说，Hekaton主要用锁机制和MVOCC的验证读集机制保证；而在**phantom avoidance**问题上，Hekaton的锁机制会对表或者表的索引加锁，来防止出现幻读；而Hekaton的MVOCC则维护了一个scan set（扫描集），通过在验证阶段对扫描集的重复扫描验证保证前后没有新增/减少元组。

## 总结

Hekaton实现了两种并行控制的方式：悲观和乐观的并行控制协议。利用锁机制来避免自己读的元组被其他事务修改导致的不可见和利用MVOCC的验证来检验自己读的元组是否仍然可见。