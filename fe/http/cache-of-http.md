# http缓存

## 缓存再命中验证
- http提供了If-Modified-Since字段，告诉服务器副本最近更新时间。
- 如果服务器未被修改，则会发送一个304 Not Modified
- 如果已被修改，则发送一次新的内容，200 Ok。
- 如果对象被删除，则发送404。

## 命中率
文档命中率，请求对象在缓存中的比例。

**字节命中率**，表示缓存提供的字节在传输所有字节中所占的比例。

客户端可以通过http返回信息中的Date首部是否比请求时间早来判断拿到的是不是缓存信息。

##  缓存的处理步骤
1. 接收：缓存从网络中读取到达的请求报文。
2. 解析：对报文进行解析，提取URL等首部
3. 查询：查看是否有缓存可用
4. 新鲜度检测：缓存查看已缓存副本是否足够新鲜。
5. 创建响应：缓存会用新的首部和已缓存的主体来构建一条响应报文。
6. 发送：通过网络将响应发送给客户端。
7. 日志：创建一条描述日志。

超过了新鲜度限值的缓存文档需要向服务端再次确认文档是否有更新。

## 文档过期
http有Cache-Control头和Expires，服务器给每个文档附加一个过期日期
```
Cache-Control: Max-Age=19000
或者
Expires: Fri，05，JUL，2002，05:00:00 GMT
```

## 用条件方法进行再验证
If-Modified-Since和If-None-Match。

http引入了Etag机制（实体标签）作为“版本标识符”。实体标签可以是附加到文档上的任意标签（引用字符串）。它们可能包含了文档的序列号或者版本名，或者是文档内容的校验和其他指纹信息。

If-None-Match可以针对这些实体标签进行比较。

服务端会用“/W”来标记弱验证器，它允许一些不重要的修改发生而不改变自己的实体标签。

## Etag生成算法
可以计算资源关联的版本、一个或多个文件属性，实体头信息和校验值，也可以计算实体信息的散列值。

如果ETag算法比较简单，可以在每次请求的时候计算一次；如果比较复杂可以考虑在每次文件修改之后存下来。

### Nginx的ETag算法
文件最后修改时间（16进制）-文件长度（16进制）

### Apache的ETag算法
- Inode：文件的索引节点数
- MTime：文件最后修改日期及时间
- Size：文件的字节数

这三个属性变成16进制并用-连接。

## 缓存控制
http的Cache-Control字段
|取值|含义|
|:-----:|:-----:|
|no-store|缓存不应该存有关服务端和客户端响应的任何内容|
|no-cache|在返回缓存之前强制进行验证|
|must-revalidate|资源过期必须重新验证|
|max-age=<seconds>|缓存有效的最大相对时间|
|max-stale=<seconds>|可以接收过期n秒内的缓存内容|
|min-fresh=<seconds>|至少在n秒内，缓存内容是新鲜的|
|only-if-cached|客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新|

### 通过http-equiv的html缓存控制
在html中使用meta标签
```
<meta http-equiv="Cache-Control" content="no-cache">
```
