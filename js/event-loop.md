# js的事件循环

## 执行栈和事件队列
执行栈用于执行同步代码，一个函数被调用/同步语句执行时就会往执行栈推入这个函数的执行环境，只要不发生栈溢出，可以一直添加。

当js遇到异步事件（ajax请求，页面事件触发等），js引擎不会等待这个事件的执行结果，会将这个异步事件的回调加入到事件队列。当执行栈为空时，主线程会去事件队列取出一个事件回调放入执行栈，执行里面的同步代码。

## 宏任务和微任务
异步任务可以被分为两类：宏任务和微任务。它们的执行优先级有区别。

宏任务事件：
- setInterval
- setTimeout

微任务事件：
- promise.then

在事件循环中，异步事件的返回结果后会被放入到一个任务队列中。根据任务的类型，这个事件会放入到宏任务队列或者微任务队列中去。在执行栈为空时，它会先去访问微任务队列是否有任务存在。如果不存在则再去宏任务队列取出一个事件放入执行栈；如果存在，依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列取出第一个事件放入当前执行栈。

**微任务队列执行完之后，如果宏任务中有多个任务，只会取出第一个，并再次将所有微任务执行完毕**

## example：
```js
new Promise((res) => {
  res(2);
}).then((num) => console.log(num));

setTimeout(() => {
  console.log(3);
  new Promise((res) => {
    console.log(4);
    res(5);
  }).then((num) => console.log(num));
}, 0);

setTimeout(() => {
  console.log(1);
}, 0);
```
输出：
```
2
3
4
5
1
```
### 解释：
**第一次事件循环：**
执行第一个Promise，并把`then((num) => console.log(num))`加入微任务；将

```js
() => {
  console.log(3);
  new Promise((res) => {
     console.log(4);
     res(5);
  }).then((num) => console.log(num));
}
```

放入宏任务队列；将

```js
() => {
  console.log(1);
}
```
放入宏任务队列（现在宏任务队列里有两个任务了）。执行栈为空。
执行微任务队列的任务：输出2。微任务队列为空。
**取出一个宏任务**，加入执行栈

**第二次事件循环：**
输出3，执行Promise，输出4；将`then((num) => console.log(num));`加入微任务队列。执行栈为空。
执行微任务：输出5；
取出一个宏任务加入执行栈。

**第三次事件循环：**
输出1；执行栈为空。
微任务为空。
宏任务为空。
